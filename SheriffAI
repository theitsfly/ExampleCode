using System.Collections;
using System.Collections.Generic;
using UnityEngine;
using UnityEngine.AI;

public class SheriffAI : MonoBehaviour
{
    public NavMeshAgent agent;
    public Transform player;
    public LayerMask whatIsPlayer, footLayer, obstruction, distractionObj, stolenObj;
    public float radius;
    [Range(0, 360)]
    public float angle;
    public bool playerStole = false;

    public float curTime = 0;
    public float startingTime = 10;
    public float curTimeLook = 0;
    public float curStartingTimeLook = 10;

    public bool isKnockedOut;
    public GameObject knockedOutEffect;

    public bool isDistracted = false;
    public bool isAtObject = false;
    public Transform distractionThing;
    public float curTimeDist = 0;
    public float startingTimeDist = 10;

    public bool patrolling = false;
    public Transform[] waypoints;
    private int curWaypoint = 0;
    private int maxWaypoint;
    public float minWaypointDistance = 0.1f;
    public float mWaitTime = 5;

    public float sightRange;
    public float attackRange;
    public float footFallRange;
    public bool playerInSightRange = false;
    public bool playerInFootFallRange = false;
    public bool playerIsClose = false;

    void Awake()
    {
        player = GameObject.FindGameObjectWithTag("Player").GetComponent<Transform>();
        agent = GetComponent<NavMeshAgent>();
        maxWaypoint = waypoints.Length - 1;
        StartCoroutine(FOVRoutineDistraction());
    }

    void Start()
    {
        curTime = startingTime;
        curTimeLook = curStartingTimeLook;
        patrolling = true;
        isKnockedOut = false;
        knockedOutEffect.SetActive(false);
    }

    void Update()
    {
        playerInFootFallRange = Physics.CheckSphere(transform.position, footFallRange, footLayer);

        if (patrolling)
        {
            Patrol();
        }

        if (playerStole)
        {
            if (playerInSightRange)
            {
                playerIsClose = false;
                patrolling = false;
                ChasePlayer();
            }
        }

        if (playerInFootFallRange && !isKnockedOut)
        {
            Quaternion targetRotation = Quaternion.LookRotation(player.transform.position - transform.position);
            transform.rotation = Quaternion.Slerp(transform.rotation, targetRotation, 1 * Time.deltaTime);
            patrolling = false;
        }

        if (playerIsClose)
        {
            agent.isStopped = true;
            playerIsClose = true;
            patrolling = false;
        }

        if (isAtObject)
        {
            agent.isStopped = true;
            patrolling = false;
            curTimeDist -= Time.deltaTime;
            if (curTimeDist < 0)
            {
                curTimeDist = 5;
                isDistracted = false;
                isAtObject = false;
                agent.isStopped = false;
                patrolling = true;
            }
        }

        if (isDistracted)
        {
            Distracted();
            patrolling = false;
        }

        if (isKnockedOut)
        {
            agent.isStopped = true;
            isKnockedOut = true;
            patrolling = false;
            playerInFootFallRange = false;
            playerInSightRange = false;
            knockedOutEffect.SetActive(true);
            curTime -= 1 * Time.deltaTime;
            if (curTime <= 0)
            {
                curTime = startingTime;
                agent.isStopped = false;
                isKnockedOut = false;
                patrolling = true;
                knockedOutEffect.SetActive(false);
            }
        }
    }

    private void Patrol()
    {
        Vector3 tempLocalPosition;
        Vector3 tempWaypointPosition;
        tempLocalPosition = transform.position;
        tempLocalPosition.y = 0f;
        tempWaypointPosition = waypoints[curWaypoint].position;
        tempWaypointPosition.y = 0f;

        if (Vector3.Distance(tempLocalPosition, tempWaypointPosition) <= minWaypointDistance)
        {
            mWaitTime -= Time.deltaTime;
            if (mWaitTime < 0)
            {
                mWaitTime = 5;
                if (curWaypoint == maxWaypoint)
                    // If so, go back to the first waypoint and start over again
                    curWaypoint = 0;
                else
                    // If we haven't reached the Last waypoint, just move on to the next one
                    curWaypoint++;
            }
        }
        agent.SetDestination(waypoints[curWaypoint].position);
    }

    private void ChasePlayer()
    {
        Vector3 targetVector = player.transform.position;
        agent.SetDestination(targetVector);
        agent.isStopped = false;
        playerIsClose = false;

        if (Vector3.Distance(transform.position, player.position) < 3)
        {
            playerIsClose = true;
        }
    }

    private void Distracted()
    {
        Vector3 targetVector = distractionThing.transform.position;
        agent.SetDestination(targetVector);
        agent.isStopped = false;
        isAtObject = false;

        if (Vector3.Distance(transform.position, distractionThing.position) < 2)
        {
            isAtObject = true;
        }
    }

    private IEnumerator Knocky()
    {
        agent.isStopped = true;
        isKnockedOut = true;
        patrolling = false;
        playerInFootFallRange = false;
        playerInSightRange = false;
        knockedOutEffect.SetActive(true);
        yield return new WaitForSeconds(10);
        agent.isStopped = false;
        isKnockedOut = false;
        patrolling = true;
        knockedOutEffect.SetActive(false);
    }

    private IEnumerator PatPoint()
    {
        yield return new WaitForSeconds(5);
    }

    private IEnumerator FOVRoutine()
    {
        WaitForSeconds wait = new WaitForSeconds(0.2f);

        while (true)
        {
            yield return wait;
            FieldOfViewCheck();
        }
    }

    private void FieldOfViewCheck()
    {
        Collider[] rangeChecks = Physics.OverlapSphere(transform.position, radius, whatIsPlayer);

        if (rangeChecks.Length != 0)
        {
            Transform target = rangeChecks[0].transform;
            Vector3 directionToTarget = (target.position - transform.position).normalized;

            if (Vector3.Angle(transform.forward, directionToTarget) < angle / 2)
            {
                float distanceToTarget = Vector3.Distance(transform.position, target.position);

                if (!Physics.Raycast(transform.position, directionToTarget, distanceToTarget, obstruction))
                    playerInSightRange = true;
            }
            else
                playerInSightRange = false;
            playerIsClose = false;
            patrolling = true;
        }
    }

    private IEnumerator FOVRoutineDistraction()
    {
        WaitForSeconds wait = new WaitForSeconds(0.2f);

        while (true)
        {
            yield return wait;
            FieldOfViewCheckDistraction();
        }
    }

    private void FieldOfViewCheckDistraction()
    {
        Collider[] rangeChecks = Physics.OverlapSphere(transform.position, radius, distractionObj);
        Collider[] rangeChecks2 = Physics.OverlapSphere(transform.position, radius, stolenObj);

        if (rangeChecks.Length != 0)
        {
            Transform target = rangeChecks[0].transform;
            Vector3 directionToTarget = (target.position - transform.position).normalized;

            if (Vector3.Angle(transform.forward, directionToTarget) < angle / 2)
            {
                float distanceToTarget = Vector3.Distance(transform.position, target.position);

                if (!Physics.Raycast(transform.position, directionToTarget, distanceToTarget, obstruction))
                    isDistracted = true;
            }
            else
                isDistracted = false;
            patrolling = true;
        }

        if (rangeChecks2.Length != 0)
        {
            Transform target = rangeChecks2[0].transform;
            Vector3 directionToTarget = (target.position - transform.position).normalized;

            if (Vector3.Angle(transform.forward, directionToTarget) < angle / 2)
            {
                float distanceToTarget = Vector3.Distance(transform.position, target.position);

                if (!Physics.Raycast(transform.position, directionToTarget, distanceToTarget, stolenObj))
                    playerStole = true;
            }
            else
                playerStole = false;
            patrolling = true;
        }

        Collider[] rangeChecks3 = Physics.OverlapSphere(transform.position, radius, whatIsPlayer);

        if (rangeChecks3.Length != 0 && playerStole)
        {
            Transform target = rangeChecks3[0].transform;
            Vector3 directionToTarget = (target.position - transform.position).normalized;

            if (Vector3.Angle(transform.forward, directionToTarget) < angle / 2)
            {
                float distanceToTarget = Vector3.Distance(transform.position, target.position);

                if (!Physics.Raycast(transform.position, directionToTarget, distanceToTarget, obstruction))
                    playerInSightRange = true;
            }
            else
                playerInSightRange = false;
            playerIsClose = false;
            patrolling = true;
        }
    }
}
